<canvas id="canvas" width="8192" height="8192"></canvas>
<script>
  const canvas = document.getElementById('canvas');
  const gl = canvas.getContext('webgl');
  if (!gl) {
    throw new Error('WebGL not supported');
  }

  // Vertex shader (full-screen quad)
  const vertexShaderSource = `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  // Fragment shader (T-Square fractal approximation)
  const fragmentShaderSource = `
    precision highp float;
    uniform vec2 u_resolution;

    // Approximates a deep iteration of the T-Square fractal
    float tSquare(in vec2 uv) {
      float d = 1.0;
      for (float i = 0.0; i < 10.0; i++) {
        vec2 a = mod(uv * d, 2.0) - 1.0;
        if (abs(a.x) < 0.5 && abs(a.y) < 0.5) {
          return 1.0;
        }
        d *= 2.0;
      }
      return 0.0;
    }

    void main() {
      // Normalize coordinates to [-1,1] with correct aspect
      vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) 
                / min(u_resolution.x, u_resolution.y);
      float c = tSquare(uv);
      gl_FragColor = vec4(vec3(c), 1.0);
    }
  `;

  // Compile helper
  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error(`Could not compile WebGL shader:\n\n${info}`);
    }
    return shader;
  }

  // Create and link program
  const vs = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
  const fs = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    const info = gl.getProgramInfoLog(program);
    gl.deleteProgram(program);
    throw new Error(`Could not link WebGL program:\n\n${info}`);
  }
  gl.useProgram(program);

  // Full-screen quad setup
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
      -1, -1,   1, -1,  -1,  1,
      -1,  1,   1, -1,   1,  1
    ]),
    gl.STATIC_DRAW
  );
  const posLoc = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  // Pass resolution uniform
  const resLoc = gl.getUniformLocation(program, 'u_resolution');
  gl.uniform2f(resLoc, canvas.width, canvas.height);

  // Draw call
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
</script>
